<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simon Ramsay</title>
    <description>A personal blog about shitty infrequent random programing tips</description>
    <link>https://ramsay.xyz/</link>
    <atom:link href="https://ramsay.xyz/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 30 Oct 2022 12:49:56 -0500</pubDate>
    <lastBuildDate>Sun, 30 Oct 2022 12:49:56 -0500</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>released some basic Caddy Docker containers</title>
        <description>&lt;h1 id=&quot;created-caddy-do-and-caddy-gandi&quot;&gt;created caddy-do and caddy-gandi&lt;/h1&gt;

&lt;p&gt;both of these containers are plain caddy containers with the DigitalOcean and Gandi DNS plugins already installed.&lt;/p&gt;

&lt;h1 id=&quot;why&quot;&gt;why?&lt;/h1&gt;
&lt;h3 id=&quot;enabled-auto-build-using-github-actions&quot;&gt;enabled auto build using github actions&lt;/h3&gt;
&lt;p&gt;keeps the base image up to date (since these ones dont need be changed)&lt;/p&gt;

&lt;h3 id=&quot;allows-for-ssl-at-home-behind-ones-nat&quot;&gt;allows for SSL at home (behind ones NAT)&lt;/h3&gt;
&lt;p&gt;I have found it handy to assign real public DNS names to my internal devices (ie: example.at.home.ramsay.xyz -&amp;gt; 10.0.0.2).&lt;/p&gt;

&lt;p&gt;Enabling HSTS on ramsay.xyz (with subdomains) has then caused my browser to refuse to connect to http only servers at home.&lt;/p&gt;

&lt;p&gt;Since Caddy usually issues certs by hosting a validation file on your server, it needs to be publicly accessible. But with DNS validation, the server can be isolated on a private network (like ones NAT at home)&lt;/p&gt;

&lt;h1 id=&quot;buy-why-ssl-home&quot;&gt;Buy why ssl home?&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;protect against local network snooping (ie: random cheap iot device, not so friendly guest)&lt;/li&gt;
  &lt;li&gt;can efforce HTTPS only CSP for self hosted site&lt;/li&gt;
  &lt;li&gt;allows one to enroll their personal domain in &lt;a href=&quot;https://hstspreload.org/&quot;&gt;HSTS preload list&lt;/a&gt; (since it requires HSTS header to includeSudDomains)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;links&quot;&gt;links&lt;/h1&gt;
&lt;h2 id=&quot;github&quot;&gt;github&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/caddy-do&quot;&gt;caddy-do&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/caddy-gandi&quot;&gt;caddy-gandi&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;containers&quot;&gt;containers&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ghcr.io/nexus-uw/caddy-do&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ghcr.io/nexus-uw/caddy-gandi&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Oct 2022 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2022/10/30/released-some-basic-docker-containers.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/10/30/released-some-basic-docker-containers.html</guid>
        
        <category>caddy</category>
        
        <category>docker</category>
        
        
      </item>
    
      <item>
        <title>0.1.0 edge-lambda-url-authorizer is now ready for use</title>
        <description>&lt;p&gt;Today I am happy to announce the release of &lt;a href=&quot;https://www.npmjs.com/package/edge-lambda-url-authorizer&quot;&gt;edge-lambda-url-authorizer 0.1.0&lt;/a&gt; (ready for actual use)&lt;/p&gt;

&lt;h1 id=&quot;what&quot;&gt;What&lt;/h1&gt;
&lt;p&gt;edge-lambda-url-authorizer is a NodeJS package (with Typescript types) to be deployed a Lambda@Edge handler for Cloudfront origin requests. This package will &lt;a href=&quot;https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html&quot;&gt;sigv4 sign&lt;/a&gt; the incomming request with the lambda’s instance credentials using &lt;a href=&quot;https://www.npmjs.com/package/aws4&quot;&gt;aws4&lt;/a&gt; before forwarding the request to the origin. The origin is expected to be a &lt;a href=&quot;https://aws.amazon.com/blogs/aws/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/&quot;&gt;Lambda Function URL&lt;/a&gt; endpoint with IAM_AUTH enabled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edge_signer.drawio.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;why-lambda-url---removed-extra-unnecessary-dependency-on-apigateway&quot;&gt;Why lambda url -&amp;gt; removed extra (unnecessary) dependency on ApiGateway.&lt;/h1&gt;
&lt;h3 id=&quot;unessarcy&quot;&gt;unessarcy&lt;/h3&gt;
&lt;p&gt;api gateway has a whole list of features and benefits for using, but for a basic ‘please expose my lambda as a public endpoint’ it is unnecessary&lt;/p&gt;

&lt;p&gt;apigateway is a separate service from lambda (so your chance of something killing your service is higher) us-west-2 had a large apigateway outage earlier this month&lt;/p&gt;

&lt;h3 id=&quot;save-a-few-pennies&quot;&gt;save a few pennies&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Function URL Pricing
Function URLs are included in Lambda’s request and duration pricing. For example, let’s imagine that you deploy a single Lambda function with 128 MB of memory and an average invocation time of 50 ms. The function receives five million requests every month, so the cost will be $1.00 for the requests, and $0.53 for the duration. The grand total is $1.53 per month, in the US East (N. Virginia) Region.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;function url does not cost extra&lt;/p&gt;

&lt;p&gt;api gateway costs $ per million requests (after the free tier) https://aws.amazon.com/api-gateway/pricing/
-&amp;gt; this tends to be a larger expense than the underlying lambda&lt;/p&gt;

&lt;p&gt;(for ammobin.ca, this line item represented almost 10% of the monthly AWS spend)&lt;/p&gt;

&lt;h1 id=&quot;challenges-with-plain-function-url&quot;&gt;challenges with plain function url&lt;/h1&gt;
&lt;h2 id=&quot;cors&quot;&gt;CORS&lt;/h2&gt;
&lt;p&gt;browsers will make CORS requests (which are supported) b/c the function url is on a different domain from one’s website. This creates an extra round trip for each actual request. (question: do OPTIONS requests add to your aws bill?)&lt;/p&gt;

&lt;h2 id=&quot;csp&quot;&gt;CSP&lt;/h2&gt;
&lt;p&gt;need to add lambda url to an Content-Security-Policy&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;different for each stage/region -&amp;gt; more work to generate/maintain&lt;/li&gt;
  &lt;li&gt;one more thing to worry about&lt;/li&gt;
  &lt;li&gt;multiple function urls require multiple domains to add to the policy&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;randomauto-generated-domain&quot;&gt;random/auto generated domain&lt;/h2&gt;
&lt;p&gt;migrating function urls now requires server updates (instead of pointing to custom domain)&lt;/p&gt;

&lt;p&gt;ppl might ask why requests are going off to some random auto generated domain?&lt;/p&gt;

&lt;p&gt;if the lambda function were to be deleted + recreated (intentionally or not), unable to get old url back -&amp;gt; risk someone might snag it or have to update a bunch of references to it
(could be very hard if hard coded in client sdks or the like)&lt;/p&gt;

&lt;h2 id=&quot;lacks-security-features-auto-scan-tools-can-complain&quot;&gt;lacks security features (auto scan tools can complain)&lt;/h2&gt;
&lt;p&gt;aws to their credit, launched with excellent iam policy support for (make sure that account is ‘secure’)
see https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html#urls-governance&lt;/p&gt;

&lt;p&gt;auto scan tools can flag ‘endpoint without authentication enabled’, enable IAM_AUTH keeps the bots off your back&lt;/p&gt;

&lt;h2 id=&quot;bot-protection&quot;&gt;bot protection&lt;/h2&gt;
&lt;p&gt;cant apply aws waf (but can use lambda throttling)&lt;/p&gt;

&lt;h2 id=&quot;caching&quot;&gt;caching&lt;/h2&gt;
&lt;p&gt;req could/should be cached. could be cached by browser, but not by cdn&lt;/p&gt;

&lt;p&gt;if one site receives enough traffic, all of these extraneous lambda invocations can start to add up&lt;/p&gt;

&lt;h1 id=&quot;solution-enable-iam_auth--cloudfront&quot;&gt;solution enable IAM_AUTH + cloudfront&lt;/h1&gt;
&lt;p&gt;have lambda@edge sign incoming origin request&lt;/p&gt;

&lt;h2 id=&quot;cloudfront-features&quot;&gt;cloudfront features&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;custom domain&lt;/li&gt;
  &lt;li&gt;caching policy&lt;/li&gt;
  &lt;li&gt;AWS Shield + WAF protection&lt;/li&gt;
  &lt;li&gt;edge routing (could also do something like https://ramsay.xyz/2022/01/05/release-of-blue-green-static-aws-edge.html to internall route to the closest aws region for backing lambda execution)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iam-auth&quot;&gt;iam auth&lt;/h2&gt;
&lt;p&gt;apply an iam resource policy (handy for cross account access)&lt;/p&gt;

&lt;p&gt;prevents people from calling your api directly (to by pass your cloudfront config)&lt;/p&gt;

&lt;p&gt;no more ‘api without authentication’ security scan issues&lt;/p&gt;

&lt;h3 id=&quot;alt&quot;&gt;alt&lt;/h3&gt;
&lt;p&gt;custom header auth -&amp;gt; brittle, not great, does not let people get creative (but current suggested solution on https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DownloadDistS3AndCustomOrigins.html#concept_lambda_function_url)&lt;/p&gt;

&lt;p&gt;sigv4 lambda is ~2ms execution time for p90 so it doesn’t cost too much (and execute on origin req, so cache reqs need no exe)&lt;/p&gt;

&lt;h3 id=&quot;issue&quot;&gt;issue&lt;/h3&gt;
&lt;p&gt;origins per distribution defaults to 25 (can be increased to ???)
https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions&lt;/p&gt;

&lt;h3 id=&quot;next-steps&quot;&gt;next steps&lt;/h3&gt;
&lt;p&gt;could be generalized further into a generic sigv4 proxy for aws resources (ie: call dynamoDb or s3 directly). but that is much more complicated (and risky). it would require a very good understanding of IAM policies to properly secure one’s resources.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 30 Oct 2022 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2022/10/30/lambda-edge-auth.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/10/30/lambda-edge-auth.html</guid>
        
        <category>lambda@edge</category>
        
        <category>typescript</category>
        
        <category>aws</category>
        
        
      </item>
    
      <item>
        <title>ramsay.xyz now on ipfs</title>
        <description>&lt;p&gt;ramsay.xyz is now available on &lt;a href=&quot;https://ipfs.io&quot;&gt;InterPlanetary File System (IPFS)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It can be easily accessed through its IPNS over at Cloudflare’s gateway &lt;a href=&quot;https://cloudflare-ipfs.com/ipns/fleek.ramsay.xyz&quot;&gt;cloudflare-ipfs.com/ipns/fleek.ramsay.xyz&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;how&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;changed the jekyll build to &lt;a href=&quot;https://developers.cloudflare.com/web3/ipfs-gateway/reference/updating-for-ipfs/#jekyll&quot;&gt;generate relative links instead of absolute links&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;deployed site using &lt;a href=&quot;https://fleek.co&quot;&gt;fleek.co&lt;/a&gt; (including setting up a dns link)&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 03 Jul 2022 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2022/07/03/ramsay.xyz-now-on-ipfs.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/07/03/ramsay.xyz-now-on-ipfs.html</guid>
        
        <category>ipfs</category>
        
        
      </item>
    
      <item>
        <title>simple upstream proxy authentication for caddy</title>
        <description>&lt;h1 id=&quot;a-very-simple-upstream-proxy-authentication-for-caddy&quot;&gt;A VERY Simple upstream proxy authentication for Caddy&lt;/h1&gt;

&lt;p&gt;Moving selfhosted services from a VPS to a machine at home can be handy for saving on VPS resources (CPU, RAM, and disk space) but exposes the risk of leaking the home IP address. To protect ones home UP address, the VPS can be used as a downstream proxy to handle incoming traffic. Having the upstream server require a special header to be set by the downstream server, helps to make sure that only the downstream sever can connect to the upstream. This is quicker and easier to deploy than a VPN.&lt;/p&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;p&gt;(Assuming that both the upstream and downstream servers are running Caddy)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://caddyserver.com/docs/caddyfile/matchers#header&quot;&gt;DOC&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;entrypoint-caddyfile&quot;&gt;Entrypoint Caddyfile&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://selfhostedservice.ramsay.xyz {
  reverse_proxy https://selfhostedservice.rabaranks.duckdns.org {
    header_up +Random some_random_string
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;upstream-caddyfile&quot;&gt;Upstream Caddyfile&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://selfhostedservice.rabaranks.duckdns.org {
  @basicauth{
      header Random some_random_string
  }
  reverse_proxy @basicauth selfhostedservice:8080
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;limitations-of-this-setup&quot;&gt;Limitations of this setup&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;it does not easily scale beyond single key&lt;/li&gt;
  &lt;li&gt;security by obscurity (ie: unexpected header used)&lt;/li&gt;
  &lt;li&gt;long lived credentials (api key is being passed over the wire and rotation requires manual edits on both the upstream and downstream servers)&lt;/li&gt;
  &lt;li&gt;since using non-standard http header, it could easily show up in server logs&lt;/li&gt;
  &lt;li&gt;creds are stored in plain text within caddyfile&lt;/li&gt;
  &lt;li&gt;upstream server will still accept direct requests + responds with blank response (indicating that something is running there + the domain name is valid)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;improvemnets&quot;&gt;improvemnets&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/&quot;&gt;mutual TLS&lt;/a&gt; (ref &lt;a href=&quot;https://caddyserver.com/docs/caddyfile/directives/tls#client_auth&quot;&gt;Caddyfile config&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;better-alternatives&quot;&gt;(Better) Alternatives&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tailscale.com/&quot;&gt;Tailscale&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/en-ca/products/tunnel/&quot;&gt;Cloudflare Tunnels&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/awesome-foss/awesome-sysadmin#vpn&quot;&gt;VPN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 09 May 2022 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2022/05/09/simple-upstream-proxy-authentication-for-caddy.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/05/09/simple-upstream-proxy-authentication-for-caddy.html</guid>
        
        <category>caddy</category>
        
        <category>security</category>
        
        
      </item>
    
      <item>
        <title>release of blue-green-static-aws-edge</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/BASED-EDGE/blue-green-static-aws-edge&quot;&gt;REPO&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This repo contains a sample reference AWS CDK stack for setting up a blue green deployed serverless distribution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A sample React javascript application is (async) chunked by webpack with a distinct buildId included in the publicPath. The cdk stack deploys the web assets to S3 (using the buildId as a the subfolder) as well as update the edge lambda to a new version with the latest buildId. AWS Code Deploy then slowly switches traffic b/w the old lambda and the new lambda. As users visit the page, they will be progressively more likely to see the new version over the old version until the deployment successfully completes. To reduce origin latency for users far away from us-east-1, a route53 latency based TXT record is used to redirect the s3Origin request to the closet s3 bucket (that contains all the same assets).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If something were to go wrong with the latest assets, (ie: code bug), the code deployment would fail and revert to the old version. Since the javascript entry should never be cached, any users who were served the bad version will get the old version after reloading the page. The same rollback action could be manually performed if an issue was discovered after the deployment completed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The major down side with this approach is having to invoke a lambda every time a user loads the widget. This can lead to incurring Lambda costs, depending the level of traffic the app receives. These costs can be lower (or more operationally acceptable) than running comparable server(s) 24/7.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Another issue is incurring addition costs from always having to fetch the index.js. This will incur a financial cost in terms of S3 GET requests as well as a performance cost of always having to fetch the asset from us-east-1 (the sample client app aggressively asynchronously loads everything in the index to minimize its size at build time and ensure that most of the app is cached at the edge by CloudFront). Using Route53 latency routing, the edge lambda was upgraded to redirect the origin request to the closest aws region + replicated bucket, to reduce distance based latency. Yet again, this introduces more (possible) line items to the AWS bill in terms of additional storage costs and DNS queries, but these should be pretty minor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/blue-green-static-aws-edge.drawio.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 05 Jan 2022 00:00:00 -0600</pubDate>
        <link>https://ramsay.xyz/2022/01/05/release-of-blue-green-static-aws-edge.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/01/05/release-of-blue-green-static-aws-edge.html</guid>
        
        <category>aws</category>
        
        <category>cdk</category>
        
        <category>serverless</category>
        
        <category>basededge.dev</category>
        
        
      </item>
    
      <item>
        <title>trashhalo/reddit-rss now support custom reddit alternative UIs</title>
        <description>&lt;p&gt;My &lt;a href=&quot;https://github.com/trashhalo/reddit-rss/pull/36&quot;&gt;PR&lt;/a&gt; was merged back in November 2021.&lt;/p&gt;

&lt;p&gt;It allows redditt-rss to serve as an improved rss feed that links to &lt;a href=&quot;https://libredd.it/&quot;&gt;libredd.it&lt;/a&gt; (simple and lightweight reddit UI) or a selfhosted version.&lt;/p&gt;

&lt;p&gt;Why not just use &lt;a href=&quot;https://teddit.net/&quot;&gt;teddit.net&lt;/a&gt; rss support?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;They serve up the same limited reddit rss item (tinny thumbnail and no further content). trashhalo/reddit-rss will attempt to pull the actual content into the rss item.&lt;/li&gt;
  &lt;li&gt;I have found the teddit pages to take a while to load. libredd.it is much faster since it contains no JS and it does not attempt to save assets to disk.&lt;/li&gt;
  &lt;li&gt;I do not have any need to interact with reddit, so the js is completely unnecessary to me&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 05 Jan 2022 00:00:00 -0600</pubDate>
        <link>https://ramsay.xyz/2022/01/05/reddit-rss.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2022/01/05/reddit-rss.html</guid>
        
        <category>rss</category>
        
        <category>reddit</category>
        
        <category>libredd</category>
        
        
      </item>
    
      <item>
        <title>Mini Madeuce - a selfhosted url shortener that does not take 14 months to replace and does not smell like brake cleaner</title>
        <description>&lt;h1 id=&quot;mini-madeuce&quot;&gt;mini-madeuce&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/mini-madeuce.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;mini madeuce is a selfhosted privacy focused url shortener&lt;/p&gt;

&lt;p&gt;url &lt;a href=&quot;https://mini-madeuce.ramsay.xyz/?ref=blog&quot;&gt;mini-madeuce.ramsay.xyz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;onion &lt;a href=&quot;http://madeucev3nrsti4nthzqt22dw2n57lseca3735yjhxddevl3zhtg3mad.onion&quot;&gt;madeucev3nrsti4nthzqt22dw2n57lseca3735yjhxddevl3zhtg3mad.onion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github &lt;a href=&quot;https://github.com/nexus-uw/mini-madeuce&quot;&gt;nexus-uw/mini-madeuce&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;sharing mokin token notes is a real pain if one has to manually type in the url (~150 characters long).&lt;/p&gt;

&lt;h2 id=&quot;how-or-things-that-make-is-special-to-the-end-user&quot;&gt;how or things that make is special to the end user&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;selfhostable (opensource + verifiable)&lt;/li&gt;
  &lt;li&gt;no js (and strict csp) greatly reduces the attack vector and ability to sneak in something else&lt;/li&gt;
  &lt;li&gt;link expiry (both time and usage). ensures that shorted url will go away&lt;/li&gt;
  &lt;li&gt;no logs or tracking (since not a business)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sample-work-flow&quot;&gt;sample work flow&lt;/h3&gt;
&lt;p&gt;Create password with massive-pass, store it using mokintoken, take the encrypted url and shorten it using mini-madeuce. Then manually enter the shorten url on the separate computer so that the password can be copy pasted&lt;/p&gt;

&lt;h3 id=&quot;threats-mini-madeuce-protects-against&quot;&gt;threats mini-madeuce protects against&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Shorted url is discovered in a data leak (ie: email hacked, droped usb stick).
  if after usage limit (default 1, max 10) or expiry (default 1, max 720 hours)
  shortened url will already been deleted from the service’s db, service does not indicate if the url ever even existed.&lt;/li&gt;
  &lt;li&gt;Shorted url is intercepted before it expires/used up. If created with the 1 use count, when the intended user of the url visits the short url, it will not work for them. If they are smart, they will know that the url has been intercepted and whatever they were using for it has been compromised. ideally they would switch communication channels.&lt;/li&gt;
  &lt;li&gt;Prevents writting down passwords in order to manually copy over to a new machine. If combined with mokin-token, long passwords can be shared with a new computer/smart phone by first encrypting with mokin-token, and then the long url is shortened by mini-madeuce. The user can then manually entered on the new machine, the full password can copypasted.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/1563630852404.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Oct 2021 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2021/10/03/mini-madeuce.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2021/10/03/mini-madeuce.html</guid>
        
        <category>selfhosted</category>
        
        <category>golang</category>
        
        <category>docker</category>
        
        <category>privacy</category>
        
        <category>dont have to worry about chemicals coming out</category>
        
        
      </item>
    
      <item>
        <title>MASSIVE PASS: an unspecial password generator</title>
        <description>&lt;p&gt;created a selfhostable password generator, massive pass&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/massive-pass&quot;&gt;CODE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://massive-pass.ramsay.xyz/&quot;&gt;live version&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://massiveeeati5xv7sszovagrkamzdtshv4sg4rzpbg6n2btwkv2f2lqd.onion/&quot;&gt;TOR&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;things-that-make-is-special&quot;&gt;things that make is special&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;selfhostable (see docker container in README)&lt;/li&gt;
  &lt;li&gt;enforces + displays the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;script integrity SHA&lt;/a&gt; which allows anyone to verify that script being served is the same script as committed to the github repo (note: this requires a production npm install to ensure that only the exact npm packages are installed). think of it as something of a reproducible build&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;why&quot;&gt;why&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;strong passwords are good&lt;/li&gt;
  &lt;li&gt;simplified site is easier to audit its resources (ie no ad networks)&lt;/li&gt;
  &lt;li&gt;selfhostable so that one can run it themselves&lt;/li&gt;
  &lt;li&gt;OSS so that the code can be reviewed&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 17 Apr 2021 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2021/04/17/massive-pass.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2021/04/17/massive-pass.html</guid>
        
        <category>massive</category>
        
        <category>pass</category>
        
        <category>password</category>
        
        <category>js</category>
        
        <category>sirv</category>
        
        
      </item>
    
      <item>
        <title>new v3 onion address</title>
        <description>&lt;p&gt;ramsay.xyz is now available at &lt;a href=&quot;http://ramsayswljlwqo7yvw3ovxhyzavllyduxkgh4rbobzkc263jyro6cjyd.onion/&quot;&gt;ramsayswljlwqo7yvw3ovxhyzavllyduxkgh4rbobzkc263jyro6cjyd.onion/&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Jan 2021 00:00:00 -0600</pubDate>
        <link>https://ramsay.xyz/2021/01/06/new-v3-onion-address.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2021/01/06/new-v3-onion-address.html</guid>
        
        <category>tor</category>
        
        <category>onion</category>
        
        
      </item>
    
      <item>
        <title>Comparison of AWS API Gateway Endpoint Types When Behind a CloudFront Distribution</title>
        <description>&lt;h1 id=&quot;background&quot;&gt;background&lt;/h1&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-endpoint-types.html&quot;&gt;official AWS documentation&lt;/a&gt; does not provide guidance around which endpoint type to use. This becomes relevant when once wants to run their entire website behind Cloudfront.&lt;/p&gt;

&lt;p&gt;http://blog.ryangreen.ca/2017/11/03/api-gateway-regional-vs-edge-optimized-endpoints/ does suggest using a REGIONAL endpoint if you also have a Cloudfront distribution, but is lacking further detail in the area.&lt;/p&gt;

&lt;h1 id=&quot;setup&quot;&gt;setup&lt;/h1&gt;
&lt;p&gt;For this test, &lt;a href=&quot;https://aws.amazon.com/cdk/&quot;&gt;AWS CDK&lt;/a&gt; was used to setup all of the infrastructure. It makes it trivial to iterate over a list of options + regions to easy generate everything very quickly (and to update it all when there was a bug). &lt;a href=&quot;https://docs.aws.amazon.com/cdk/latest/guide/work-with-cdk-csharp.html&quot;&gt;C#&lt;/a&gt; was selected as the language only as a change of pace from the Java + Typescript used at work but to preserve static typing.&lt;/p&gt;

&lt;p&gt;The all the infrastructure under test was created in us-east-1. Four identical Cloudfront distributions were created with no caching and response compression enabled. Each distribution had one origin pointing to an API Gateway. Each API Gateway was generated with a combination of EDGE/REGIONAL endpoint type and response compression enabled/disabled so as to test all the different combinations. The api had a single lambda integration pointing to the same lambda. The lambda was written in javascript using nodejs 12 and configured with 125MB of ram. The lambda would immediately respond with 256KB of random text (so as to reflect real world non-cachable responses).&lt;/p&gt;

&lt;p&gt;For collecting the test data, a lambda was deployed to every AWS commercial region. The test lambda was again written in javascript, using the nodejs 12 runtime with 125MB of memory configured. For the test, it would make GET requests to the given distribution and wait for the request to finish downloading the response. The clientside measured load time was emitted to cloudwatch as a custom metric.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edgy-regions-basic-aws-diagram.png&quot; alt=&quot;aws architecture diagram&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;execution&quot;&gt;execution&lt;/h1&gt;
&lt;p&gt;All tests where run async’ly at the same time using the lambda cli on 2020 09 20 21:00:00 UTC. Each test lambda was run for 15mins, and no errors were reported at this time.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/edgy-regions/blob/master/loadtest.bash&quot;&gt;test script used&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;results&lt;/h1&gt;

&lt;h3 id=&quot;clientside-response-time-metrics&quot;&gt;clientside response time metrics&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edgy-regions-p50-response-time-by-region-distribution.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edgy-regions-p90-response-time-by-region-distribution.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/edgy-regions/blob/master/20200919_results/20200919%20Regional%20Edge%20Load%20Testing%20-%20Sheet1.csv&quot;&gt;source dataset csv&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;additional-cloudfront-distribution-metrics&quot;&gt;additional Cloudfront distribution metrics&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Origin latency
The total time spent from when CloudFront receives a request to when it starts providing a response to the network (not the viewer), for requests that are served from the origin, not the CloudFront cache. This is also known as first byte latency, or time-to-first-byte. &lt;a href=&quot;https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional&quot;&gt;src&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edgy-regions-p50-cloudfront-origin-latency.png&quot; alt=&quot;p50 origin latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/edgy-regions-p90-cloudfront-origin-latency.png&quot; alt=&quot;p90 origin latency&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;conclusions&quot;&gt;conclusions&lt;/h1&gt;

&lt;h3 id=&quot;regional-is-the-preferred-api-gateway-endpoint-type-when-behind-a-custom-cloudfront-distribution&quot;&gt;REGIONAL is the preferred API Gateway endpoint type when behind a custom Cloudfront distribution&lt;/h3&gt;

&lt;p&gt;The response times for all regions were lower when the endpoint type was REGIONAL. This is expected because REGIONAL endpoints have one fewer ‘hops’ (no built in Cloudfront distribution) to go through to get to the lambda integration.
A ~10% response time improvement was observed during the test when using a REGIONAL endpoint.&lt;/p&gt;

&lt;h3 id=&quot;api-gateway-compression-is-only-suggested-for-far-away-users&quot;&gt;API Gateway compression is only suggested for far away users&lt;/h3&gt;
&lt;p&gt;Nearby users will see a small performance hit, but far away users will see a larger performance gain. Ideally, one would place another API gateway closer to their faraway users if there was enough of them to justify the cost + complexity.&lt;/p&gt;

&lt;p&gt;Additionally, compression only added to the response time of EDGE endpoints.&lt;/p&gt;

&lt;h1 id=&quot;sources&quot;&gt;sources&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nexus-uw/edgy-regions&quot;&gt;github repo with all related code + results dataset&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 19 Sep 2020 00:00:00 -0500</pubDate>
        <link>https://ramsay.xyz/2020/09/19/regional-vs-edge-aws-api-gateway-endpoint-type-comparison.html</link>
        <guid isPermaLink="true">https://ramsay.xyz/2020/09/19/regional-vs-edge-aws-api-gateway-endpoint-type-comparison.html</guid>
        
        <category>api gateway</category>
        
        <category>cloudfront</category>
        
        <category>cdk</category>
        
        <category>c#</category>
        
        <category>lambda</category>
        
        
      </item>
    
  </channel>
</rss>
